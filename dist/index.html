<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script>
    /** --- THE MODEL --- **/
    class ActorModel {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.gridSize = 8;
        this.speed = 2; // Pixel increment per frame

        // State for step-locking
        this.isMoving = false;
        this.remainingStep = 0;
        this.currentDir = 'down';

        this.hp = 6;
        this.invincibleTimer = 0;
        this.isKnockedBack = false;
        this.knockbackDist = 0;
      }

      // Semantic behavior: Take 8px steps
      process(inputDir, room) {
        if (this.invincibleTimer > 0) this.invincibleTimer--;

        if (this.isKnockedBack) {
          const speed = 4;
          let dx = 0, dy = 0;
          // Move opposite to facing direction
          if (this.currentDir === 'left') dx = speed;
          if (this.currentDir === 'right') dx = -speed;
          if (this.currentDir === 'up') dy = speed;
          if (this.currentDir === 'down') dy = -speed;

          const nextX = this.x + dx;
          const nextY = this.y + dy;

          if (this.canPass(nextX, nextY, room)) {
            this.x = nextX;
            this.y = nextY;
          }

          this.knockbackDist -= speed;
          if (this.knockbackDist <= 0) {
            this.isKnockedBack = false;
            // Snap to grid
            this.x = Math.round(this.x / this.gridSize) * this.gridSize;
            this.y = Math.round(this.y / this.gridSize) * this.gridSize;
          }
          return;
        }

        // If we are mid-step, keep moving until the 8px is exhausted
        if (this.isMoving) {
          let dx = 0, dy = 0;
          if (this.currentDir === 'left') dx = -this.speed;
          if (this.currentDir === 'right') dx = this.speed;
          if (this.currentDir === 'up') dy = -this.speed;
          if (this.currentDir === 'down') dy = this.speed;

          const nextX = this.x + dx;
          const nextY = this.y + dy;

          // Collision check: only move if the path is clear
          if (this.canPass(nextX, nextY, room)) {
            this.x = nextX;
            this.y = nextY;
            this.remainingStep -= this.speed;
          } else {
            // If we hit a wall mid-step, cancel the remaining step
            this.remainingStep = 0;
          }

          // Check if step is complete
          if (this.remainingStep <= 0) {
            this.isMoving = false;
            // Final hard snap to ensure no floating point errors
            this.x = Math.round(this.x / this.gridSize) * this.gridSize;
            this.y = Math.round(this.y / this.gridSize) * this.gridSize;
          }
        }

        // If we aren't currently mid-step (or just finished), look for new input
        if (!this.isMoving && inputDir) {
          this.currentDir = inputDir;
          this.isMoving = true;
          this.remainingStep = this.gridSize;

          // Perpendicular snap (Lane alignment)
          if (inputDir === 'left' || inputDir === 'right') {
            this.y = Math.round(this.y / this.gridSize) * this.gridSize;
          } else {
            this.x = Math.round(this.x / this.gridSize) * this.gridSize;
          }
        }
      }

      canPass(nx, ny, room) {
        const cs = room.cornerSize;
        const fs = room.floorSize;
        const limit = cs + fs;
        const margin = 8; // Player half-size

        // Floor bounds
        const inFloorX = nx >= cs + margin && nx <= limit - margin;
        const inFloorY = ny >= cs + margin && ny <= limit - margin;
        if (inFloorX && inFloorY) return true;

        // Doorways (center is 128, door sprite is 32px wide from 112 to 144)
        const mid = 128;
        // This is the half-width of the allowed path for the player's center.
        // A 16px player passing through a 16px opening has 0px of lateral movement.
        const dw = 0;
        if (room.wallTypes.n === 'open' && nx >= mid - dw && nx <= mid + dw && ny < cs + margin) return true;
        if (room.wallTypes.s === 'open' && nx >= mid - dw && nx <= mid + dw && ny > limit - margin) return true;
        if (room.wallTypes.w === 'open' && ny >= mid - dw && ny <= mid + dw && nx < cs + margin) return true;
        if (room.wallTypes.e === 'open' && ny >= mid - dw && ny <= mid + dw && nx > limit - margin) return true;

        return false;
      }

      takeDamage(amount, srcX, srcY) {
        if (this.invincibleTimer > 0) return false;
        this.hp -= amount;
        this.invincibleTimer = 30;
        this.knockback(srcX, srcY);
        return this.hp <= 0;
      }

      knockback(srcX, srcY) {
        this.isKnockedBack = true;
        this.knockbackDist = 32;
        this.isMoving = false;
        this.remainingStep = 0;

        const dx = srcX - this.x;
        const dy = srcY - this.y;
        if (Math.abs(dx) > Math.abs(dy)) this.currentDir = dx > 0 ? 'right' : 'left';
        else this.currentDir = dy > 0 ? 'down' : 'up';
      }
    }

    class MonsterModel extends ActorModel {
      constructor(x, y, type) {
        super(x, y);
        this.type = type;
        this.hp = 3;
        this.aiTimer = 0;
        this.speed = 1; // Monsters are typically slower than the player
      }

      ai(room) {
        if (this.isKnockedBack) {
          this.process(null, room);
          return;
        }

        // If currently moving, continue that movement
        if (this.isMoving) {
          this.process(null, room);
          return;
        }

        // If waiting, count down
        if (this.aiTimer > 0) {
          this.aiTimer--;
          return;
        }

        // Pick a random direction
        const dirs = ['up', 'down', 'left', 'right'];
        const pick = dirs[Math.floor(Math.random() * dirs.length)];
        this.process(pick, room);

        // Set a pause timer
        if (!this.isMoving) this.aiTimer = 30 + Math.floor(Math.random() * 30);
      }
    }

    class MoblinModel extends MonsterModel {
      constructor(x, y) {
        super(x, y, 'moblin');
        this.speed = 0.25;
      }
    }

    class RoomModel {
      constructor() {
        this.cornerSize = 32;
        this.floorSize = 192;
        this.wallTypes = { n: 'open', s: 'solid', e: 'solid', w: 'solid' };
      }
    }

    const SKIN_CONFIG = {
      startPos: { x: 256, y: 0 },
      frameSize: { w: 16, h: 16 },
      skins: [
        "Link", "Zelda", "Shiek", "Impa", "Ganondorf", "Darunia", "Ruto", "Agitha",
        "Midna", "Fi", "Ghirarim", "Zant", "Lana", "Cia", "Volga", "Wizzro",
        "Twili Midna", "Kid Link", "Tingle", "Linkle", "Skull Kid", "Toon Link",
        "Tetra", "King Daphnes", "Medli", "Marin", "Toon Zelda", "Yuga"
      ],
      anims: {
        down: { start: 0, length: 2, rate: 8, repeat: -1 },
        up: { start: 2, length: 2, rate: 8, repeat: -1 },
        left: { start: 4, length: 2, rate: 8, repeat: -1 },
        right: { start: 6, length: 2, rate: 8, repeat: -1 },
        atk_down: { start: 8, length: 1, rate: 10, repeat: 0 },
        atk_up: { start: 9, length: 1, rate: 10, repeat: 0 },
        atk_left: { start: 10, length: 1, rate: 10, repeat: 0 },
        atk_right: { start: 11, length: 1, rate: 10, repeat: 0 },
        item_1h: { start: 12, length: 1, rate: 10, repeat: 0 },
        item_2h: { start: 13, length: 1, rate: 10, repeat: 0 }
      }
    };

    const WEAPON_CONFIG = {
      startPos: { x: 64, y: 416 },
      frameSize: { w: 16, h: 16 },
      names: [
        "Rapier", "Biggoron's Sword", "Sword of Demise", "Hammer",
        "Shadow Scimitar", "Protector Sword", "Dragon Spear",
        "Cutlass of Light", "Demon Sword", "Master Sword"
      ]
    };

    const ITEM_CONFIG = {
      startPos: { x: 64, y: 432 },
      frameSize: { w: 16, h: 16 },
      names: [
        "Nothing", "Blue Ring", "Red Ring", "Blue Bracelet", "Red Bracelet",
        "Moon Pearl", "Fire Pearl", "Bombos Medallion", "Ether Medallion", "Quake Medallion"
      ]
    };

    /** --- THE VIEW (Phaser) --- **/
    class DungeonScene extends Phaser.Scene {
      preload() {
        // Load the master sheet once
        this.load.image('master_sheet', 'graphics.png');
      }

      create() {
        this.roomModel = new RoomModel();
        this.playerModel = new ActorModel(128, 128);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.loadDoors();

        // 1. Create the Room Base
        // We use a "Frame" to grab just the 256x256 room from the giant sheet
        // Define frame: .add(name, sourceIndex, x, y, width, height)
        this.textures.get('master_sheet').add('room_bg', 0, 0, 64, 256, 256);
        this.add.image(0, 0, 'master_sheet', 'room_bg').setOrigin(0);

        // 1.5 Draw doors based on the RoomModel
        const doorPositions = {
          n: { x: 112, y: 0 },
          s: { x: 112, y: 224 },
          w: { x: 0, y: 112 },
          e: { x: 224, y: 112 }
        };
        for (const [wall, type] of Object.entries(this.roomModel.wallTypes)) {
          const pos = doorPositions[wall];
          const textureName = `door_${wall}_${type}`;
          this.add.image(pos.x, pos.y, 'master_sheet', textureName).setOrigin(0);
        }

        this.loadEnemies();
        this.enemies = [];
        this.createEnemyAnims();
        this.spawnEnemy(192, 128, 'moblin');
        this.currentWeapon = 'Rapier';
        this.isAttacking = false;

        // Input Stack for "Last Key Priority"
        this.inputStack = [];
        const keyMap = {
          [Phaser.Input.Keyboard.KeyCodes.LEFT]: 'left',
          [Phaser.Input.Keyboard.KeyCodes.RIGHT]: 'right',
          [Phaser.Input.Keyboard.KeyCodes.UP]: 'up',
          [Phaser.Input.Keyboard.KeyCodes.DOWN]: 'down'
        };
        this.input.keyboard.on('keydown', (event) => {
          const dir = keyMap[event.keyCode];
          if (dir && !this.inputStack.includes(dir)) this.inputStack.push(dir);
        });
        this.input.keyboard.on('keyup', (event) => {
          const dir = keyMap[event.keyCode];
          if (dir) this.inputStack = this.inputStack.filter(d => d !== dir);
        });
        this.input.keyboard.on('keydown-SPACE', () => {
          this.performAttack();
        });

        // 2. Define the Player Animation
        this.loadSkin('Link');
        this.loadWeapons();
        this.loadItems();

        this.weaponView = this.add.sprite(0, 0, 'master_sheet');
        this.weaponView.setVisible(false);

        this.playerView = this.add.sprite(128, 128, 'master_sheet');
        this.playerView.setDepth(1);
        this.playerView.play('down');
      }

      loadSkin(skinName) {
        const idx = SKIN_CONFIG.skins.indexOf(skinName);
        if (idx === -1) return;

        const { x: startX, y: startY } = SKIN_CONFIG.startPos;
        const { w, h } = SKIN_CONFIG.frameSize;
        const skinY = startY + (idx * h);

        // Create animations for this skin
        for (const [animKey, config] of Object.entries(SKIN_CONFIG.anims)) {
          const frames = [];
          for (let i = 0; i < config.length; i++) {
            const frameName = `${skinName}_${animKey}_${i}`;
            // Add frame to texture manager
            this.textures.get('master_sheet').add(
              frameName, 0,
              startX + (config.start + i) * w, skinY, w, h
            );
            frames.push({ key: 'master_sheet', frame: frameName });
          }
          // Remove existing if switching skins
          this.anims.remove(animKey);
          this.anims.create({
            key: animKey,
            frames: frames,
            frameRate: config.rate,
            repeat: config.repeat
          });
        }
      }

      loadWeapons() {
        const { x: startX, y: startY } = WEAPON_CONFIG.startPos;
        const { w, h } = WEAPON_CONFIG.frameSize;

        WEAPON_CONFIG.names.forEach((name, i) => {
          this.textures.get('master_sheet').add(
            `weapon_${name}`,
            0,
            startX + (i * w),
            startY,
            w,
            h
          );
        });
      }

      loadItems() {
        const { x: startX, y: startY } = ITEM_CONFIG.startPos;
        const { w, h } = ITEM_CONFIG.frameSize;

        ITEM_CONFIG.names.forEach((name, i) => {
          this.textures.get('master_sheet').add(
            `item_${name}`,
            0,
            startX + (i * w),
            startY,
            w,
            h
          );
        });
      }

      loadEnemies() {
        const sheet = this.textures.get('master_sheet');

        // Gleeok
        for (let i = 0; i < 3; i++) {
          sheet.add(`gleeok_body_${i}`, 0, i * 32, 320, 32, 32);
        }
        sheet.add('gleeok_neck', 0, 96, 320, 16, 16);
        sheet.add('gleeok_head', 0, 96, 336, 16, 16);

        // Gohma
        sheet.add('gohma_legs_left_0', 0, 0, 352, 16, 16);
        sheet.add('gohma_legs_left_1', 0, 16, 352, 16, 16);
        sheet.add('gohma_legs_right_0', 0, 32, 352, 16, 16);
        sheet.add('gohma_legs_right_1', 0, 48, 352, 16, 16);

        // Manhandla
        sheet.add('manhandla_mouth_left_0', 0, 64, 352, 16, 16);
        sheet.add('manhandla_mouth_left_1', 0, 80, 352, 16, 16);
        sheet.add('manhandla_mouth_top_0', 0, 96, 352, 16, 16);
        sheet.add('manhandla_mouth_top_1', 0, 112, 352, 16, 16);
        sheet.add('manhandla_mouth_right_0', 0, 64, 368, 16, 16);
        sheet.add('manhandla_mouth_right_1', 0, 80, 368, 16, 16);
        sheet.add('manhandla_mouth_bottom_0', 0, 96, 368, 16, 16);
        sheet.add('manhandla_mouth_bottom_1', 0, 112, 368, 16, 16);
        sheet.add('manhandla_body', 0, 128, 352, 16, 16);

        // Dodongo
        ['walk0', 'walk1', 'hurt'].forEach((n, i) => {
          sheet.add(`dodongo_down_${n}`, 0, 144 + i * 16, 320, 16, 16);
          sheet.add(`dodongo_up_${n}`, 0, 192 + i * 16, 320, 16, 16);
          sheet.add(`dodongo_left_${n}`, 0, 144 + i * 32, 336, 32, 16);
          sheet.add(`dodongo_right_${n}`, 0, 144 + i * 32, 352, 32, 16);
        });

        // Keese, Gel, Zol
        ['keese', 'gel', 'zol'].forEach((name, idx) => {
          const startX = 144 + (idx * 32);
          sheet.add(`${name}_0`, 0, startX, 368, 16, 16);
          sheet.add(`${name}_1`, 0, startX + 16, 368, 16, 16);
        });

        // Standard Enemies
        const loadStandard = (name, sx, sy) => {
          sheet.add(`${name}_down_0`, 0, sx, sy, 16, 16);
          sheet.add(`${name}_down_1`, 0, sx + 16, sy, 16, 16);
          sheet.add(`${name}_up_0`, 0, sx + 32, sy, 16, 16);
          sheet.add(`${name}_up_1`, 0, sx + 48, sy, 16, 16);
          sheet.add(`${name}_left_0`, 0, sx, sy + 16, 16, 16);
          sheet.add(`${name}_left_1`, 0, sx + 16, sy + 16, 16, 16);
          sheet.add(`${name}_right_0`, 0, sx + 32, sy + 16, 16, 16);
          sheet.add(`${name}_right_1`, 0, sx + 48, sy + 16, 16, 16);
        };

        loadStandard('goriya', 0, 384);
        loadStandard('moblin', 0, 416);
        loadStandard('darknut', 64, 384);
        loadStandard('octorok', 128, 384);
        loadStandard('lynel', 192, 384);
      }

      createEnemyAnims() {
        const types = ['moblin', 'goriya', 'darknut', 'octorok', 'lynel'];
        types.forEach(type => {
          ['down', 'up', 'left', 'right'].forEach(dir => {
            this.anims.create({
              key: `${type}_${dir}`,
              frames: [
                { key: 'master_sheet', frame: `${type}_${dir}_0` },
                { key: 'master_sheet', frame: `${type}_${dir}_1` }
              ],
              frameRate: 6,
              repeat: -1
            });
          });
        });
      }

      spawnEnemy(x, y, type) {
        let model;
        if (type === 'moblin') model = new MoblinModel(x, y);
        else model = new MonsterModel(x, y, type);

        const sprite = this.add.sprite(x, y, 'master_sheet');
        sprite.play(`${type}_down`);
        this.enemies.push({ model, sprite });
      }

      loadDoors() {
        const walls = ['n', 's', 'w', 'e'];
        const types = ['solid', 'open', 'locked', 'shut'];

        walls.forEach((wall, i) => {
          // Row 0 contains N (left) and S (right)
          // Row 1 contains W (left) and E (right)
          const row = i < 2 ? 0 : 1;
          const colOffset = (i % 2) * 4; // 0 or 4

          types.forEach((type, j) => {
            const x = (colOffset + j) * 32;
            const y = row * 32;
            this.textures.get('master_sheet').add(`door_${wall}_${type}`, 0, x, y, 32, 32);
          });
        });
      }

      performAttack() {
        if (this.isAttacking) return;
        this.isAttacking = true;

        const dir = this.playerModel.currentDir;
        this.playerView.play(`atk_${dir}`);

        this.weaponView.setTexture('master_sheet', `weapon_${this.currentWeapon}`);
        this.weaponView.setVisible(true);
        this.updateWeaponPosition();

        this.time.delayedCall(250, () => {
          this.isAttacking = false;
          this.weaponView.setVisible(false);
        });

        // Attack Hitbox Check
        const { x, y, currentDir } = this.playerModel;
        const reach = 20;
        let hx = x, hy = y;
        if (currentDir === 'left') hx -= reach;
        if (currentDir === 'right') hx += reach;
        if (currentDir === 'up') hy -= reach;
        if (currentDir === 'down') hy += reach;

        for (let i = this.enemies.length - 1; i >= 0; i--) {
          const e = this.enemies[i];
          if (Math.abs(e.model.x - hx) < 16 && Math.abs(e.model.y - hy) < 16) {
            e.sprite.setTint(0xff0000);
            this.time.delayedCall(150, () => { if (e.sprite.scene) e.sprite.clearTint(); });
            if (e.model.takeDamage(1, this.playerModel.x, this.playerModel.y)) {
              e.sprite.destroy();
              this.enemies.splice(i, 1);
            }
          }
        }
      }

      updateWeaponPosition() {
        const dir = this.playerModel.currentDir;
        const offset = 12;
        const { x, y } = this.playerModel;

        if (dir === 'left') {
          this.weaponView.setPosition(x - offset, y);
          this.weaponView.setAngle(0);
        } else if (dir === 'right') {
          this.weaponView.setPosition(x + offset, y);
          this.weaponView.setAngle(180);
        } else if (dir === 'up') {
          this.weaponView.setPosition(x, y - offset);
          this.weaponView.setAngle(90);
        } else if (dir === 'down') {
          this.weaponView.setPosition(x, y + offset);
          this.weaponView.setAngle(-90);
        }
      }

      update() {
        const inputDir = (this.inputStack.length > 0 && !this.isAttacking) ? this.inputStack[this.inputStack.length - 1] : null;

        this.playerModel.process(inputDir, this.roomModel);
        this.playerView.setPosition(this.playerModel.x, this.playerModel.y);
        if (this.isAttacking) this.updateWeaponPosition();

        const dir = this.playerModel.currentDir;
        if (this.isAttacking) return;

        if (this.playerModel.isMoving) {
          this.playerView.play(dir, true);
        } else {
          this.playerView.stop();
          // Set to the first frame of the current direction (standing pose)
          const firstFrame = this.anims.get(dir).frames[0].frame.name;
          this.playerView.setFrame(firstFrame);
        }

        // Player vs Enemy Collision
        const px = this.playerModel.x;
        const py = this.playerModel.y;
        this.enemies.forEach(e => {
          if (Math.abs(e.model.x - px) < 12 && Math.abs(e.model.y - py) < 12) {
            this.playerModel.takeDamage(1, e.model.x, e.model.y);
          }
        });

        // Update Enemies
        this.enemies.forEach(e => {
          e.model.ai(this.roomModel);
          e.sprite.setPosition(e.model.x, e.model.y);
          if (e.model.isMoving) {
            e.sprite.play(`${e.model.type}_${e.model.currentDir}`, true);
          } else {
            e.sprite.stop();
          }
        });
      }
    }

    new Phaser.Game({
      type: Phaser.AUTO,
      width: 256, height: 256,
      pixelArt: true,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      scene: DungeonScene
    });
  </script>
</body>

</html>