<!DOCTYPE html>
<html>

<head>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      background: #000;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script>
    /** --- THE MODEL --- **/
    class ActorModel {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.gridSize = 8;
        this.speed = 2; // Pixel increment per frame

        // State for step-locking
        this.isMoving = false;
        this.remainingStep = 0;
        this.currentDir = 'down';
      }

      // Semantic behavior: Take 8px steps
      process(inputDir, room) {
        // If we are mid-step, keep moving until the 8px is exhausted
        if (this.isMoving) {
          let dx = 0, dy = 0;
          if (this.currentDir === 'left') dx = -this.speed;
          if (this.currentDir === 'right') dx = this.speed;
          if (this.currentDir === 'up') dy = -this.speed;
          if (this.currentDir === 'down') dy = this.speed;

          const nextX = this.x + dx;
          const nextY = this.y + dy;

          // Collision check: only move if the path is clear
          if (this.canPass(nextX, nextY, room)) {
            this.x = nextX;
            this.y = nextY;
            this.remainingStep -= this.speed;
          } else {
            // If we hit a wall mid-step, cancel the remaining step
            this.remainingStep = 0;
          }

          // Check if step is complete
          if (this.remainingStep <= 0) {
            this.isMoving = false;
            // Final hard snap to ensure no floating point errors
            this.x = Math.round(this.x / this.gridSize) * this.gridSize;
            this.y = Math.round(this.y / this.gridSize) * this.gridSize;
          }
        }

        // If we aren't currently mid-step (or just finished), look for new input
        if (!this.isMoving && inputDir) {
          this.currentDir = inputDir;
          this.isMoving = true;
          this.remainingStep = this.gridSize;

          // Perpendicular snap (Lane alignment)
          if (inputDir === 'left' || inputDir === 'right') {
            this.y = Math.round(this.y / this.gridSize) * this.gridSize;
          } else {
            this.x = Math.round(this.x / this.gridSize) * this.gridSize;
          }
        }
      }

      canPass(nx, ny, room) {
        const cs = room.cornerSize;
        const fs = room.floorSize;
        const limit = cs + fs;
        const margin = 8; // Player half-size

        // Floor bounds
        const inFloorX = nx >= cs + margin && nx <= limit - margin;
        const inFloorY = ny >= cs + margin && ny <= limit - margin;
        if (inFloorX && inFloorY) return true;

        // Doorways (center is 128, door sprite is 32px wide from 112 to 144)
        const mid = 128;
        // This is the half-width of the allowed path for the player's center.
        // A 16px player passing through a 16px opening has 0px of lateral movement.
        const dw = 0;
        if (room.wallTypes.n === 'open' && nx >= mid - dw && nx <= mid + dw && ny < cs + margin) return true;
        if (room.wallTypes.s === 'open' && nx >= mid - dw && nx <= mid + dw && ny > limit - margin) return true;
        if (room.wallTypes.w === 'open' && ny >= mid - dw && ny <= mid + dw && nx < cs + margin) return true;
        if (room.wallTypes.e === 'open' && ny >= mid - dw && ny <= mid + dw && nx > limit - margin) return true;

        return false;
      }
    }

    class RoomModel {
      constructor() {
        this.cornerSize = 32;
        this.floorSize = 192;
        this.wallTypes = { n: 'open', s: 'solid', e: 'solid', w: 'solid' };
      }
    }

    /** --- THE VIEW (Phaser) --- **/
    //class DungeonScene extends Phaser.Scene {
    //    create() {
    //        this.roomModel = { cornerSize: 32, floorSize: 192, wallTypes: { n: 'open', s: 'solid', e: 'solid', w: 'solid' } };
    //        this.playerModel = new ActorModel(128, 128);
    //        
    //        // Render 9-patch room
    //        this.renderRoom();
    //        this.playerView = this.add.rectangle(0, 0, 16, 16, 0xff0000);
    //        this.cursors = this.input.keyboard.createCursorKeys();
    //    }
    //
    //    renderRoom() {
    //        const { cornerSize: cs, floorSize: fs } = this.roomModel;
    //        this.add.rectangle(cs, cs, fs, fs, 0x333333).setOrigin(0); // Floor
    //        // Corners
    //        const c = 0x111111;
    //        this.add.rectangle(0, 0, cs, cs, c).setOrigin(0);
    //        this.add.rectangle(cs+fs, 0, cs, cs, c).setOrigin(0);
    //        this.add.rectangle(0, cs+fs, cs, cs, c).setOrigin(0);
    //        this.add.rectangle(cs+fs, cs+fs, cs, cs, c).setOrigin(0);
    //        // Walls
    //        const w = 0x222222;
    //        this.add.rectangle(cs, 0, fs, cs, this.roomModel.wallTypes.n === 'open' ? 0x0000ff : w).setOrigin(0);
    //        this.add.rectangle(cs, cs+fs, fs, cs, w).setOrigin(0);
    //        this.add.rectangle(0, cs, cs, fs, w).setOrigin(0);
    //        this.add.rectangle(cs+fs, cs, cs, fs, w).setOrigin(0);
    //    }
    //
    //    update() {
    //        let inputDir = null;
    //        if (this.cursors.left.isDown) inputDir = 'left';
    //        else if (this.cursors.right.isDown) inputDir = 'right';
    //        else if (this.cursors.up.isDown) inputDir = 'up';
    //        else if (this.cursors.down.isDown) inputDir = 'down';
    //
    //        this.playerModel.process(inputDir, this.roomModel);
    //        this.playerView.setPosition(this.playerModel.x, this.playerModel.y);
    //    }
    //}

    const SKIN_CONFIG = {
      startPos: { x: 256, y: 0 },
      frameSize: { w: 16, h: 16 },
      skins: [
        "Link", "Zelda", "Shiek", "Impa", "Ganondorf", "Darunia", "Ruto", "Agitha",
        "Midna", "Fi", "Ghirarim", "Zant", "Lana", "Cia", "Volga", "Wizzro",
        "Twili Midna", "Kid Link", "Tingle", "Linkle", "Skull Kid", "Toon Link",
        "Tetra", "King Daphnes", "Medli", "Marin", "Toon Zelda", "Yuga"
      ],
      anims: {
        down: { start: 0, length: 2, rate: 8, repeat: -1 },
        up: { start: 2, length: 2, rate: 8, repeat: -1 },
        left: { start: 4, length: 2, rate: 8, repeat: -1 },
        right: { start: 6, length: 2, rate: 8, repeat: -1 },
        atk_down: { start: 8, length: 1, rate: 10, repeat: 0 },
        atk_up: { start: 9, length: 1, rate: 10, repeat: 0 },
        atk_left: { start: 10, length: 1, rate: 10, repeat: 0 },
        atk_right: { start: 11, length: 1, rate: 10, repeat: 0 },
        item_1h: { start: 12, length: 1, rate: 10, repeat: 0 },
        item_2h: { start: 13, length: 1, rate: 10, repeat: 0 }
      }
    };

    const WEAPON_CONFIG = {
      startPos: { x: 64, y: 416 },
      frameSize: { w: 16, h: 16 },
      names: [
        "Rapier", "Biggoron's Sword", "Sword of Demise", "Hammer",
        "Shadow Scimitar", "Protector Sword", "Dragon Spear",
        "Cutlass of Light", "Demon Sword", "Master Sword"
      ]
    };

    const ITEM_CONFIG = {
      startPos: { x: 64, y: 432 },
      frameSize: { w: 16, h: 16 },
      names: [
        "Nothing", "Blue Ring", "Red Ring", "Blue Bracelet", "Red Bracelet",
        "Moon Pearl", "Fire Pearl", "Bombos Medallion", "Ether Medallion", "Quake Medallion"
      ]
    };

    /** --- THE VIEW (Phaser) --- **/
    class DungeonScene extends Phaser.Scene {
      preload() {
        // Load the master sheet once
        this.load.image('master_sheet', 'graphics.png');
      }

      create() {
        this.roomModel = new RoomModel();
        this.playerModel = new ActorModel(128, 128);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.loadDoors();
        this.currentWeapon = 'Rapier';
        this.isAttacking = false;

        // Input Stack for "Last Key Priority"
        this.inputStack = [];
        const keyMap = {
          [Phaser.Input.Keyboard.KeyCodes.LEFT]: 'left',
          [Phaser.Input.Keyboard.KeyCodes.RIGHT]: 'right',
          [Phaser.Input.Keyboard.KeyCodes.UP]: 'up',
          [Phaser.Input.Keyboard.KeyCodes.DOWN]: 'down'
        };
        this.input.keyboard.on('keydown', (event) => {
          const dir = keyMap[event.keyCode];
          if (dir && !this.inputStack.includes(dir)) this.inputStack.push(dir);
        });
        this.input.keyboard.on('keyup', (event) => {
          const dir = keyMap[event.keyCode];
          if (dir) this.inputStack = this.inputStack.filter(d => d !== dir);
        });
        this.input.keyboard.on('keydown-SPACE', () => {
          this.performAttack();
        });

        // 1. Create the Room Base
        // We use a "Frame" to grab just the 256x256 room from the giant sheet
        // Define frame: .add(name, sourceIndex, x, y, width, height)
        this.textures.get('master_sheet').add('room_bg', 0, 0, 64, 256, 256);
        this.add.image(0, 0, 'master_sheet', 'room_bg').setOrigin(0);

        // 1.5 Draw doors based on the RoomModel
        const doorPositions = {
          n: { x: 112, y: 0 },
          s: { x: 112, y: 224 },
          w: { x: 0, y: 112 },
          e: { x: 224, y: 112 }
        };
        for (const [wall, type] of Object.entries(this.roomModel.wallTypes)) {
          const pos = doorPositions[wall];
          const textureName = `door_${wall}_${type}`;
          this.add.image(pos.x, pos.y, 'master_sheet', textureName).setOrigin(0);
        }

        // 2. Define the Player Animation
        this.loadSkin('Link');
        this.loadWeapons();
        this.loadItems();

        this.weaponView = this.add.sprite(0, 0, 'master_sheet');
        this.weaponView.setVisible(false);

        this.playerView = this.add.sprite(128, 128, 'master_sheet');
        this.playerView.setDepth(1);
        this.playerView.play('down');
      }

      loadSkin(skinName) {
        const idx = SKIN_CONFIG.skins.indexOf(skinName);
        if (idx === -1) return;

        const { x: startX, y: startY } = SKIN_CONFIG.startPos;
        const { w, h } = SKIN_CONFIG.frameSize;
        const skinY = startY + (idx * h);

        // Create animations for this skin
        for (const [animKey, config] of Object.entries(SKIN_CONFIG.anims)) {
          const frames = [];
          for (let i = 0; i < config.length; i++) {
            const frameName = `${skinName}_${animKey}_${i}`;
            // Add frame to texture manager
            this.textures.get('master_sheet').add(
              frameName, 0,
              startX + (config.start + i) * w, skinY, w, h
            );
            frames.push({ key: 'master_sheet', frame: frameName });
          }
          // Remove existing if switching skins
          this.anims.remove(animKey);
          this.anims.create({
            key: animKey,
            frames: frames,
            frameRate: config.rate,
            repeat: config.repeat
          });
        }
      }

      loadWeapons() {
        const { x: startX, y: startY } = WEAPON_CONFIG.startPos;
        const { w, h } = WEAPON_CONFIG.frameSize;

        WEAPON_CONFIG.names.forEach((name, i) => {
          this.textures.get('master_sheet').add(
            `weapon_${name}`,
            0,
            startX + (i * w),
            startY,
            w,
            h
          );
        });
      }

      loadItems() {
        const { x: startX, y: startY } = ITEM_CONFIG.startPos;
        const { w, h } = ITEM_CONFIG.frameSize;

        ITEM_CONFIG.names.forEach((name, i) => {
          this.textures.get('master_sheet').add(
            `item_${name}`,
            0,
            startX + (i * w),
            startY,
            w,
            h
          );
        });
      }

      loadDoors() {
        const walls = ['n', 's', 'w', 'e'];
        const types = ['solid', 'open', 'locked', 'shut'];

        walls.forEach((wall, i) => {
          // Row 0 contains N (left) and S (right)
          // Row 1 contains W (left) and E (right)
          const row = i < 2 ? 0 : 1;
          const colOffset = (i % 2) * 4; // 0 or 4

          types.forEach((type, j) => {
            const x = (colOffset + j) * 32;
            const y = row * 32;
            this.textures.get('master_sheet').add(`door_${wall}_${type}`, 0, x, y, 32, 32);
          });
        });
      }

      performAttack() {
        if (this.isAttacking) return;
        this.isAttacking = true;

        const dir = this.playerModel.currentDir;
        this.playerView.play(`atk_${dir}`);

        this.weaponView.setTexture('master_sheet', `weapon_${this.currentWeapon}`);
        this.weaponView.setVisible(true);
        this.updateWeaponPosition();

        this.time.delayedCall(250, () => {
          this.isAttacking = false;
          this.weaponView.setVisible(false);
        });
      }

      updateWeaponPosition() {
        const dir = this.playerModel.currentDir;
        const offset = 12;
        const { x, y } = this.playerModel;

        if (dir === 'left') {
          this.weaponView.setPosition(x - offset, y);
          this.weaponView.setAngle(0);
        } else if (dir === 'right') {
          this.weaponView.setPosition(x + offset, y);
          this.weaponView.setAngle(180);
        } else if (dir === 'up') {
          this.weaponView.setPosition(x, y - offset);
          this.weaponView.setAngle(90);
        } else if (dir === 'down') {
          this.weaponView.setPosition(x, y + offset);
          this.weaponView.setAngle(-90);
        }
      }

      update() {
        const inputDir = (this.inputStack.length > 0 && !this.isAttacking) ? this.inputStack[this.inputStack.length - 1] : null;

        this.playerModel.process(inputDir, this.roomModel);
        this.playerView.setPosition(this.playerModel.x, this.playerModel.y);
        if (this.isAttacking) this.updateWeaponPosition();

        const dir = this.playerModel.currentDir;
        if (this.isAttacking) return;

        if (this.playerModel.isMoving) {
          this.playerView.play(dir, true);
        } else {
          this.playerView.stop();
          // Set to the first frame of the current direction (standing pose)
          const firstFrame = this.anims.get(dir).frames[0].frame.name;
          this.playerView.setFrame(firstFrame);
        }
      }
    }

    new Phaser.Game({
      type: Phaser.AUTO,
      width: 256, height: 256,
      pixelArt: true,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      scene: DungeonScene
    });
  </script>
</body>

</html>